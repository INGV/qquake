# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QQuake, a QGIS Plugin for Loading Seismological Data From Web Services
 
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-11-20
        git sha              : $Format:%H$
        copyright            : Istituto Nazionale di Geofisica e Vulcanologia (INGV)
        email                : mario.locati@ingv.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import json
from copy import deepcopy
from qgis.PyQt import uic
from qgis.PyQt.QtWidgets import (
    QWidget,
    QDialog,
    QVBoxLayout,
    QDialogButtonBox,
    QCheckBox,
    QSpinBox
)
from qgis.PyQt.QtCore import QDateTime, Qt, pyqtSignal

from qgis.core import (
    Qgis,
)
from qgis.gui import (
    QgsGui,
)

from qquake.gui.gui_utils import GuiUtils
from qquake.services import SERVICE_MANAGER

FORM_CLASS, _ = uic.loadUiType(GuiUtils.get_ui_file_path('service_configuration_widget_base.ui'))


class ServiceConfigurationWidget(QWidget, FORM_CLASS):
    WIDGET_MAP = {
        'queryeventid': 'check_filter_by_eventid',
        'queryoriginid': 'check_filter_by_originid',
        'querymagnitudeid': 'check_filter_by_magnitudeid',
        'queryfocalmechanismid': 'check_filter_by_focalmechanismid',
        'queryupdatedafter': 'check_filter_data_updated_after',
        'querycatalog': 'check_filter_by_catalog',
        'querycontributor': 'check_filter_by_contributor',
        'querycontributorid': 'check_filter_by_contributorid',
        'queryeventtype': 'check_filter_by_event_type',
        'querymagnitudetype': 'check_filter_by_magnitude_type',
        'queryincludeallorigins': 'check_can_include_all_origins',
        'queryincludeallmagnitudes': 'check_can_include_all_magnitudes',
        'queryincludearrivals': 'check_can_include_arrivals',
        'queryincludeallstationsmagnitudes': 'check_can_include_all_stations_magnitudes',
        'querylimit': 'check_has_limit_of_entries',
        'querylimitmaxentries': 'spin_has_limit_of_entries',
        'querycircular': 'check_can_filter_using_circular_area',
        'querycircularradiuskm': 'check_radius_of_circular_area_is_specified_in_km',
        'querydepth': 'check_can_filter_by_depth',
        'outputtext': 'check_can_output_text',
        'outputxml': 'check_can_output_xml',
        'outputgeojson': 'check_can_output_geojson',
        'outputjson': 'check_can_output_json',
        'outputkml': 'check_can_output_kml',
        'outputxlsx': 'check_can_output_microsoft_xlsx'
    }

    validChanged = pyqtSignal(bool)

    def __init__(self, iface, service_type, service_id, parent=None):
        """Constructor."""
        super().__init__(parent)

        self.setupUi(self)

        self.qml_style_name_combo.addItem('')
        self.qml_style_name_combo_mdp.addItem('')
        for name, props in SERVICE_MANAGER.PRESET_STYLES.items():
            if props['type'] in ('events', 'stations'):
                self.qml_style_name_combo.addItem(name)
            elif props['type'] == 'macroseismic':
                self.qml_style_name_combo_mdp.addItem(name)

        self.service_type = service_type
        self.service_id = service_id

        self.start_date_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")
        self.end_date_edit.setDisplayFormat("yyyy-MM-dd HH:mm:ss")

        if service_id in SERVICE_MANAGER.available_services(service_type):
            config = SERVICE_MANAGER.service_details(service_type, service_id)
        else:
            config = {}
        self.set_state_from_config(config)

        self.title_edit.textChanged.connect(self._changed)
        self.web_service_url_edit.textChanged.connect(self._changed)

        self.combo_http_code_nodata.addItem('204', '204')

        for _, w in self.WIDGET_MAP.items():
            widget = getattr(self, w)
            if isinstance(widget, QCheckBox):
                widget.toggled.connect(self._changed)
            elif isinstance(widget, QSpinBox):
                widget.valueChanged.connect(self._changed)
        self.check_http_code_nodata.toggled.connect(self._changed)
        self.combo_http_code_nodata.currentIndexChanged.connect(self._changed)

        if self.service_type in (SERVICE_MANAGER.WMS, SERVICE_MANAGER.WFS):
            for w in [self.group_capabilities, self.group_bounding_box]:
                w.setEnabled(False)
                w.hide()
        else:
            self.group_ogc_layers.setEnabled(False)
            self.group_ogc_layers.hide()

        if self.service_type == SERVICE_MANAGER.FDSNSTATION:
            for w in [self.check_filter_by_eventid,
                      self.check_filter_by_originid,
                      self.check_filter_by_magnitudeid,
                      self.check_filter_by_focalmechanismid,
                      self.check_filter_by_catalog,
                      self.check_filter_by_contributor,
                      self.check_filter_by_contributorid,
                      self.check_filter_by_event_type,
                      self.check_filter_by_magnitude_type,
                      self.check_can_include_all_origins,
                      self.check_can_include_all_magnitudes,
                      self.check_can_include_arrivals,
                      self.check_can_include_all_stations_magnitudes,
                      self.check_has_limit_of_entries,
                      self.spin_has_limit_of_entries,
                      self.check_can_filter_by_depth]:
                w.setEnabled(False)

        self._changed()

    def _changed(self):

        self.combo_http_code_nodata.setEnabled(self.check_http_code_nodata.isChecked())
        self.spin_has_limit_of_entries.setEnabled(self.check_has_limit_of_entries.isChecked())
        self.check_radius_of_circular_area_is_specified_in_km.setEnabled(
            self.check_can_filter_using_circular_area.isChecked())

        res, reason = self.is_valid()
        if not res:
            self.message_bar.clearWidgets()
            self.message_bar.pushMessage('', reason, Qgis.Warning, 0)
            self.validChanged.emit(False)
        else:
            self.message_bar.clearWidgets()
            self.validChanged.emit(True)

    def is_valid(self):
        if not self.title_edit.text():
            return False, self.tr('A title must be entered')

        if not self.web_service_url_edit.text():
            return False, self.tr('The web service URL must be entered')

        return True, None

    def set_state_from_config(self, config):
        self.title_edit.setText(config.get('title'))
        self.service_description_edit.setText(config.get('servicedescription'))
        self.service_description_url_edit.setText(config.get('servicedescriptionurl'))
        self.data_description_edit.setText(config.get('datadescription'))
        self.data_description_url_edit.setText(config.get('datadescriptionurl'))
        self.publications_text_edit.setPlainText('\n'.join(config.get('publications')) if isinstance(config.get('publications'), list) else str(config.get('publications')))
        self.webservice_manual_url_edit.setText(config.get('manualurl'))
        self.data_license_edit.setText(config.get('datalicense'))
        self.data_license_url_edit.setText(config.get('datalicenseurl'))
        self.data_provider_edit.setText(config.get('dataprovider'))
        self.data_provider_url_edit.setText(config.get('dataproviderurl'))
        self.web_service_url_edit.setText(config.get('endpointurl'))
        self.qml_style_url_edit.setText(config.get('styleurl'))
        if isinstance(config.get('default', {}).get('style'), str):
            self.qml_style_name_combo.setCurrentIndex(self.qml_style_name_combo.findText(config.get('default', {}).get('style')))
        else:
            self.qml_style_name_combo.setCurrentIndex(
                self.qml_style_name_combo.findText(config.get('default', {}).get('style', {}).get('style')))

        self.qml_style_url_edit_mdp.setText(config.get('mdpstyleurl'))
        self.qml_style_name_combo_mdp.setCurrentIndex(
            self.qml_style_name_combo_mdp.findText(config.get('default', {}).get('mdp_style')))

        if config.get('datestart'):
            self.start_date_edit.setDateTime(QDateTime.fromString(config.get('datestart'), Qt.ISODate))
        else:
            self.start_date_edit.clear()

        if config.get('dateend'):
            self.end_date_edit.setDateTime(QDateTime.fromString(config.get('dateend'), Qt.ISODate))
        else:
            self.end_date_edit.clear()

        extent = config.get('boundingbox')
        if extent:
            self.min_lat_spin.setValue(extent[1])
            self.max_lat_spin.setValue(extent[3])
            self.min_long_spin.setValue(extent[0])
            self.max_long_spin.setValue(extent[2])
        else:
            self.min_lat_spin.setValue(-90)
            self.max_lat_spin.setValue(90)
            self.min_long_spin.setValue(-180)
            self.max_long_spin.setValue(180)

        for key, w in self.WIDGET_MAP.items():
            widget = getattr(self, w)
            if isinstance(widget, QCheckBox):
                widget.setChecked(config.get('settings', {}).get(key, False))
            elif isinstance(widget, QSpinBox):
                if key in config.get('settings', {}):
                    widget.setValue(int(config.get('settings', {}).get(key)))

        self.check_http_code_nodata.setChecked('httpcodenodata' in config.get('settings', {}))
        self.combo_http_code_nodata.setCurrentIndex(
            self.combo_http_code_nodata.findData(config.get('settings', {}).get('httpcodenodata', '204')))

        if self.group_ogc_layers.isEnabled():
            self.ogc_layers_edit.setText(json.dumps(config.get('default', {}).get('layers', []), indent=4))

    def get_config(self):
        if self.service_id in SERVICE_MANAGER.available_services(self.service_type):
            config = deepcopy(SERVICE_MANAGER.service_details(self.service_type, self.service_id))
        else:
            config = {
                'default': {},
                'settings': {}
            }

        config['title'] = self.title_edit.text()
        config['servicedescription'] = self.service_description_edit.text()
        config['servicedescriptionurl'] = self.service_description_url_edit.text()
        config['datadescription'] = self.data_description_edit.text()
        config['datadescriptionurl'] = self.data_description_url_edit.text()
        config['publications'] = [] if not self.publications_text_edit.toPlainText() else self.publications_text_edit.toPlainText().split('\n')
        config['manualurl'] = self.webservice_manual_url_edit.text()
        config['datalicense'] = self.data_license_edit.text()
        config['datalicenseurl'] = self.data_license_url_edit.text()
        config['dataprovider'] = self.data_provider_edit.text()
        config['dataproviderurl'] = self.data_provider_url_edit.text()
        config['endpointurl'] = self.web_service_url_edit.text()
        config['styleurl'] = self.qml_style_url_edit.text()
        config['default']['style'] = self.qml_style_name_combo.currentText()

        config['mdpstyleurl'] = self.qml_style_url_edit_mdp.text()
        config['default']['mdp_style'] = self.qml_style_name_combo_mdp.currentText()

        if self.start_date_edit.dateTime().isValid():
            config['datestart'] = self.start_date_edit.dateTime().toString(Qt.ISODate)
        else:
            config['datestart'] = ''

        if self.end_date_edit.dateTime().isValid():
            config['dateend'] = self.end_date_edit.dateTime().toString(Qt.ISODate)
        else:
            config['dateend'] = ''

        if self.group_bounding_box.isEnabled():
            bounding_box = [self.min_long_spin.value(),
                            self.min_lat_spin.value(),
                            self.max_long_spin.value(),
                            self.max_lat_spin.value()]
            config['boundingbox'] = bounding_box

        if self.group_capabilities.isEnabled():
            settings = {}
            for key, w in self.WIDGET_MAP.items():
                widget = getattr(self, w)
                if not widget.isEnabled():
                    continue

                if isinstance(widget, QCheckBox):
                    settings[key] = widget.isChecked()
                elif isinstance(widget, QSpinBox):
                    settings[key] = widget.value()

            if self.check_http_code_nodata.isChecked():
                settings['httpcodenodata'] = self.combo_http_code_nodata.currentData()

            config['settings'] = settings

        if self.group_ogc_layers.isEnabled():
            config['default']['layers'] = json.loads(self.ogc_layers_edit.text())

        return config

    def save_changes(self):
        config = self.get_config()
        SERVICE_MANAGER.save_service(self.service_type, self.service_id, config)


class ServiceConfigurationDialog(QDialog):

    def __init__(self, iface, service_type, service_id, parent):
        super().__init__(parent)
        self.setObjectName('ServiceConfigurationDialog')

        QgsGui.enableAutoGeometryRestore(self)

        self.setWindowTitle(self.tr('Edit Service {}').format(service_id))

        self.config_widget = ServiceConfigurationWidget(iface, service_type, service_id)
        layout = QVBoxLayout()
        layout.addWidget(self.config_widget, 1)
        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)
        self.setLayout(layout)
        self.config_widget.validChanged.connect(self.valid_changed)
        self.valid_changed(self.config_widget.is_valid()[0])

    def valid_changed(self, is_valid):
        self.button_box.button(QDialogButtonBox.Ok).setEnabled(is_valid)

    def accept(self):
        self.config_widget.save_changes()
        super().accept()
